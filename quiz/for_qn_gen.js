/**
 * for_qn_gen.js
 * Generates quiz questions for Python basic for loops using range() (summation).
 * Includes incrementing/decrementing loops, variable steps, and continue/break statements.
 * Uses randomized variable names for loop control and accumulator.
 * Initializes accumulator with a random value between -4 and 9.
 * Medium questions include an else block to modify the accumulator.
 * Accumulates the loop variable. Range uses literal values.
 * @module for_qn_gen
 */

// --- Configuration ---
const isLoggingEnabled = false; // Set to true for debugging logs

/**
 * Logs messages to the console if logging is enabled.
 * @param {...any} args - Arguments to log.
 */
function log(...args) {
  if (isLoggingEnabled) {
    console.log('[for_qn_gen]', ...args); // Added prefix for clarity
  }
}

// --- Constants ---
// Using similar ranges as while_qn_gen for consistency
const LOOP_RANGE_MIN = 1; // Min value for loop start/end boundary
const LOOP_RANGE_MAX = 15; // Max value for loop start/end boundary
const LOOP_MAX_DIFF = 5; // Max difference between start and end
const LOOP_END_MAX = LOOP_RANGE_MAX + LOOP_MAX_DIFF; // Absolute max boundary
const EXCLUDE_DIVISORS = Object.freeze([2, 3, 5]);
const LOOP_ACTIONS = Object.freeze(['continue', 'break']); // Actions for hard questions
const INCREMENT_STEPS = Object.freeze([1, 2]); // Possible steps for incrementing loops
const DECREMENT_STEPS = Object.freeze([-1, -2]); // Possible steps for decrementing loops
const MAX_GENERATION_ATTEMPTS_MULTIPLIER = 10; // Increased slightly due to more complex generation
const ACCUMULATOR_INIT_MIN = -4; // Min initial value for accumulator
const ACCUMULATOR_INIT_MAX = 9;  // Max initial value for accumulator
const MEDIUM_ELSE_ACTIONS = Object.freeze(['increment', 'decrement']); // Actions for medium else block
const MEDIUM_ELSE_VALUE_MIN = 1; // Min value for medium else modification
const MEDIUM_ELSE_VALUE_MAX = 5;  // Max value for medium else modification

// --- Variable Names ---
const LOOP_VAR_NAMES = Object.freeze(['a', 'b', 'c', 'd', 'm', 'n', 'p', 'q', 'x', 'y', 'z']);
const ACCUMULATOR_VAR_NAMES = Object.freeze(['sum', 'total']);

// --- Modules ---

/**
 * Utility functions for number-related operations.
 * @namespace NumberUtils
 */
const NumberUtils = {
  /**
   * Generates a random integer between min and max (inclusive).
   * @param {number} min - The minimum value.
   * @param {number} max - The maximum value.
   * @returns {number} A random integer.
   */
  getRandomInt: function (min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    if (min > max) { // Handle cases where min might exceed max due to calculations
        [min, max] = [max, min]; // Swap them
    }
    return Math.floor(Math.random() * (max - min + 1)) + min;
  },

  /**
   * Selects a random element from an array.
   * @template T
   * @param {T[]} list - The array to choose from.
   * @returns {T} A random element from the array.
   */
   getRandomElement: function(list) {
    if (!list || list.length === 0) {
        throw new Error("Cannot get random element from empty or invalid list.");
    }
    return list[Math.floor(Math.random() * list.length)];
  },

   /**
   * Selects N distinct random elements from an array.
   * @template T
   * @param {T[]} list - The array to choose from.
   * @param {number} count - The number of distinct elements to select.
   * @returns {T[]} An array containing N distinct random elements.
   * @throws {Error} If the list has fewer than N elements or count is invalid.
   */
   getNDistinctRandomElements: function(list, count) {
    if (!list || list.length < count || count < 1) {
        throw new Error(`Cannot get ${count} distinct random elements from a list with ${list?.length ?? 0} items.`);
    }
    const shuffled = [...list].sort(() => 0.5 - Math.random());
    return shuffled.slice(0, count);
  },


  /**
   * Simulates Python's range function to generate the sequence of numbers.
   * @param {number} start - The starting value.
   * @param {number} stop - The stopping value (exclusive).
   * @param {number} step - The step value.
   * @returns {number[]} An array of numbers generated by the range.
   */
  simulateRange: function(start, stop, step) {
    const result = [];
    if (step === 0) {
        log("Warning: Step cannot be zero in range simulation.");
        return [];
    }
    if (step > 0) {
        for (let i = start; i < stop; i += step) {
            result.push(i);
        }
    } else { // step < 0
        for (let i = start; i > stop; i += step) {
            result.push(i);
        }
    }
    return result;
  }
};

/**
 * Functions for formatting Python code snippets for for loop questions.
 * @namespace QuestionFormatter
 */
const QuestionFormatter = {
  /**
   * Formats the range arguments based on start, end (inclusive), and step.
   * Uses literal numeric values.
   * @param {number} n - The starting value of the loop.
   * @param {number} m - The ending value (inclusive) of the loop.
   * @param {number} step - The step value.
   * @returns {string} Formatted range arguments string (e.g., "1, 6, 1" or "10, 0, -2").
   */
  formatRangeArgs: (n, m, step) => {
    let stop;
    if (step > 0) {
        stop = m + 1; // Go one past m for inclusion
    } else { // step < 0
        stop = m - 1; // Go one past m (in the negative direction) for inclusion
    }
    // Only include step if it's not 1
    return step === 1 ? `${n}, ${stop}` : `${n}, ${stop}, ${step}`;
  },

  /** Formats an easy for loop summation question using range(). */
  formatForLoopSumEasy: (loopVarName, accumulatorName, initialAccumulatorValue, n, m, step) => {
    const rangeArgs = QuestionFormatter.formatRangeArgs(n, m, step);
    // Accumulate loopVarName
    return `${accumulatorName} = ${initialAccumulatorValue}\nfor ${loopVarName} in range(${rangeArgs}):\n    ${accumulatorName} += ${loopVarName}\nprint(${accumulatorName})`;
  },

  /** Formats a medium for loop summation question using range() with an exclusion condition and else modification. */
  formatForLoopSumMedium: (loopVarName, accumulatorName, initialAccumulatorValue, n, m, step, excludeDivisor, elseAction, elseValue) => {
    const rangeArgs = QuestionFormatter.formatRangeArgs(n, m, step);
    const elseOperator = elseAction === 'increment' ? '+=' : '-=';
    // Accumulate loopVarName in the 'if' block
    return `${accumulatorName} = ${initialAccumulatorValue}\nfor ${loopVarName} in range(${rangeArgs}):\n    if ${loopVarName} % ${excludeDivisor} != 0:\n        ${accumulatorName} += ${loopVarName}\n    else:\n        ${accumulatorName} ${elseOperator} ${elseValue}\nprint(${accumulatorName})`;
  },

  /** Formats a hard for loop summation question using range() with conditional continue/break. */
  formatForLoopSumHard: (loopVarName, accumulatorName, initialAccumulatorValue, n, m, step, conditionValue, action) => {
    const rangeArgs = QuestionFormatter.formatRangeArgs(n, m, step);
    const conditionCheck = `if ${loopVarName} == ${conditionValue}:`;
    const actionStatement = action === 'continue' ? `    continue` : `    break`;
    // Accumulate loopVarName
    return `${accumulatorName} = ${initialAccumulatorValue}\nfor ${loopVarName} in range(${rangeArgs}):\n    ${conditionCheck}\n    ${actionStatement}\n    ${accumulatorName} += ${loopVarName}\nprint(${accumulatorName})`;
  }
};

/**
 * Functions for generating specific types of for loop questions.
 * @namespace QuestionGenerator
 */
const QuestionGenerator = {
   /**
   * Creates the final question object structure for for loops.
   * @param {string} questionText - The formatted Python code snippet.
   * @param {string} answer - The expected output string.
   * @param {'easy'|'medium'|'hard'} difficulty - The difficulty level.
   * @returns {object} The question object.
   */
  createQuestionEntry: function(questionText, answer, difficulty) {
    const finalAnswer = String(answer ?? ""); // Ensure string answer
    const entry = {
      topic: 'python',
      subtopic: 'for loops', // Correct subtopic
      difficulty: difficulty,
      type: 'fill',
      // Added 'python' tag for markdown code block highlighting
      question: `What will be the output of the following code?\n\n\`\`\`${questionText}\n\`\`\``,
      answer: finalAnswer,
    };
    log(`Generated for loop entry: ${JSON.stringify(entry)}`);
    return entry;
  },

  /** Generates an 'easy' for loop summation question. */
  genForLoopSumEasy: function(params) {
    const { loopVarName, accumulatorName, initialAccumulatorValue, n, m, step } = params;
    log(`Generating for loop sum (easy) question with ${loopVarName}, ${accumulatorName}=${initialAccumulatorValue}, n=${n}, m=${m}, step=${step}`);

    // Calculate the correct sum by simulating the range, starting with initial value
    let total = initialAccumulatorValue; // Start simulation with the initial value
    const stop = step > 0 ? m + 1 : m - 1;
    const sequence = NumberUtils.simulateRange(n, stop, step);

    for (const i of sequence) {
        total += i; // Always add the loop variable value
    }

    const questionText = QuestionFormatter.formatForLoopSumEasy(loopVarName, accumulatorName, initialAccumulatorValue, n, m, step);
    const answer = String(total);

    return QuestionGenerator.createQuestionEntry(questionText, answer, 'easy');
  },

  /** Generates a 'medium' for loop summation question with exclusion and else modification. */
  genForLoopSumMedium: function(params) {
    const { loopVarName, accumulatorName, initialAccumulatorValue, n, m, step, excludeDivisor, elseAction, elseValue } = params;
    log(`Generating for loop sum (medium) question with ${loopVarName}, ${accumulatorName}=${initialAccumulatorValue}, n=${n}, m=${m}, step=${step}, exclude=${excludeDivisor}, elseAction=${elseAction}, elseValue=${elseValue}`);

    // Calculate the correct sum, excluding multiples, applying else modification, starting with initial value
    let total = initialAccumulatorValue; // Start simulation with the initial value
    const stop = step > 0 ? m + 1 : m - 1;
    const sequence = NumberUtils.simulateRange(n, stop, step);

    for (const i of sequence) {
        if (i % excludeDivisor !== 0) {
            total += i; // Always add the loop variable value
        } else {
            // Apply the else modification
            if (elseAction === 'increment') {
                total += elseValue;
            } else { // decrement
                total -= elseValue;
            }
        }
    }

    const questionText = QuestionFormatter.formatForLoopSumMedium(loopVarName, accumulatorName, initialAccumulatorValue, n, m, step, excludeDivisor, elseAction, elseValue);
    const answer = String(total);

    return QuestionGenerator.createQuestionEntry(questionText, answer, 'medium');
  },

  /** Generates a 'hard' for loop summation question with conditional continue/break. */
  genForLoopSumHard: function(params) {
    const { loopVarName, accumulatorName, initialAccumulatorValue, n, m, step, conditionValue, action } = params;
    log(`Generating for loop sum (hard) question with ${loopVarName}, ${accumulatorName}=${initialAccumulatorValue}, n=${n}, m=${m}, step=${step}, conditionValue=${conditionValue}, action=${action}`);

    // Calculate the correct sum, considering continue/break, starting with initial value
    let total = initialAccumulatorValue; // Start simulation with the initial value
    const stop = step > 0 ? m + 1 : m - 1;
    const sequence = NumberUtils.simulateRange(n, stop, step);

    for (const i of sequence) {
        if (i == conditionValue) {
            if (action === 'continue') {
                continue; // Skip the rest of the loop body for this iteration
            } else { // action === 'break'
                break; // Exit the loop immediately
            }
        }
        total += i; // Always add the loop variable value
    }

    const questionText = QuestionFormatter.formatForLoopSumHard(loopVarName, accumulatorName, initialAccumulatorValue, n, m, step, conditionValue, action);
    const answer = String(total);

    return QuestionGenerator.createQuestionEntry(questionText, answer, 'hard');
  }
};

/**
 * Generates parameters for For Loop questions.
 * Includes n, m, step, direction, excludeDivisor, conditionValue, action,
 * randomized variable names (loopVarName, accumulatorName),
 * a random initial accumulator value, and parameters for the medium else block.
 * @returns {object|null} An object containing the generated parameters, or null if generation fails.
 */
function getRandomForLoopParams() {
    log(`Entering getRandomForLoopParams`);
    let n, m, step, direction, conditionValue;
    let loopVarName, accumulatorName;

    // Select loop and accumulator variable names (must be distinct)
    [loopVarName] = NumberUtils.getNDistinctRandomElements(LOOP_VAR_NAMES, 1);
    [accumulatorName] = NumberUtils.getNDistinctRandomElements(ACCUMULATOR_VAR_NAMES, 1);
    // Ensure loopVarName and accumulatorName are distinct (though unlikely with current lists)
    if (loopVarName === accumulatorName) {
        log("Warning: loopVarName and accumulatorName collided, retrying parameter generation.");
        return null; // Retry if names collide
    }

    // Generate random initial value for the accumulator
    const initialAccumulatorValue = NumberUtils.getRandomInt(ACCUMULATOR_INIT_MIN, ACCUMULATOR_INIT_MAX);

    // Generate parameters for the medium else block
    const elseAction = NumberUtils.getRandomElement(MEDIUM_ELSE_ACTIONS);
    const elseValue = NumberUtils.getRandomInt(MEDIUM_ELSE_VALUE_MIN, MEDIUM_ELSE_VALUE_MAX);

    // Decide direction first (50/50 chance)
    direction = NumberUtils.getRandomElement(['increment', 'decrement']);

    // --- Generate Loop Boundaries (n, m, step) ---
    if (direction === 'increment') {
        step = NumberUtils.getRandomElement(INCREMENT_STEPS);
        n = NumberUtils.getRandomInt(LOOP_RANGE_MIN, LOOP_RANGE_MAX); // This is the start value
        const minM = n;
        const maxM = Math.min(n + LOOP_MAX_DIFF, LOOP_END_MAX);
        if (minM > maxM) {
             log("Cannot generate valid incrementing range (minM > maxM), retrying...");
             return null;
        }
        m = NumberUtils.getRandomInt(minM, maxM);
        const stopSimCheck = m + 1;
        if (NumberUtils.simulateRange(n, stopSimCheck, step).length === 0) {
            log(`Generated incrementing range (n=${n}, m=${m}, step=${step}) is empty, retrying...`);
            return null;
        }
        conditionValue = NumberUtils.getRandomInt(n, m);

    } else { // direction === 'decrement'
        step = NumberUtils.getRandomElement(DECREMENT_STEPS);
        m = NumberUtils.getRandomInt(LOOP_RANGE_MIN, LOOP_RANGE_MAX); // This is the end value
        const minN = m;
        const maxN = Math.min(m + LOOP_MAX_DIFF, LOOP_END_MAX);
         if (minN > maxN) {
             log("Cannot generate valid decrementing range (minN > maxN), retrying...");
             return null;
        }
        n = NumberUtils.getRandomInt(minN, maxN); // This is the start value
        const stopSimCheck = m - 1;
        if (NumberUtils.simulateRange(n, stopSimCheck, step).length === 0) {
            log(`Generated decrementing range (n=${n}, m=${m}, step=${step}) is empty, retrying...`);
            return null;
        }
        conditionValue = NumberUtils.getRandomInt(m, n);
    }
    // const startValue = n; // No longer needed as a separate variable for accumulation logic

    // --- Ensure conditionValue is reachable ---
    const stopSim = step > 0 ? m + 1 : m - 1;
    const possibleValues = NumberUtils.simulateRange(n, stopSim, step);
    if (possibleValues.length === 0) {
         log("Generated range is unexpectedly empty after parameter selection, retrying...");
         return null;
    }
    if (!possibleValues.includes(conditionValue)) {
        // Adjust conditionValue to the nearest reachable value within the sequence
        conditionValue = possibleValues.reduce((prev, curr) => {
            return (Math.abs(curr - conditionValue) < Math.abs(prev - conditionValue) ? curr : prev);
        });
        log(`Adjusted conditionValue to be reachable: ${conditionValue}`);
    }

    // --- Other Parameters ---
    const excludeDivisor = NumberUtils.getRandomElement(EXCLUDE_DIVISORS);
    const action = NumberUtils.getRandomElement(LOOP_ACTIONS); // For hard questions

    log(`Exiting getRandomForLoopParams with loopVar=${loopVarName}, acc=${accumulatorName}, init=${initialAccumulatorValue}, n=${n}, m=${m}, step=${step}, dir=${direction}, exclude=${excludeDivisor}, conditionValue=${conditionValue}, action=${action}, elseAction=${elseAction}, elseValue=${elseValue}`);
    return {
        loopVarName, accumulatorName, initialAccumulatorValue,
        n, m, step, direction, excludeDivisor, conditionValue, action,
        elseAction, elseValue,
        // Removed accumulateTargetName, startVarName, startValue
    };
}

/**
 * Generates a specified number of random for loop questions covering all difficulties.
 * Ensures an attempt to generate one of each difficulty (easy, medium, hard) per parameter set.
 * Uses randomized variable names and initial accumulator values.
 * Medium questions include an else block modification.
 * Accumulates the loop variable. Range uses literal values.
 * @param {number} numQuestions - The total number of questions to generate.
 * @returns {Array<object>} An array of generated question objects.
 * @alias module:for_qn_gen.genForQns
 */
function genForQns(numQuestions) {
  log(`Generating ${numQuestions} for loop questions (attempting all difficulties per param set)...`);
  const questions = [];
  let attempts = 0;
  // Adjust maxAttempts slightly, as each attempt tries to generate 3 questions
  const maxAttempts = Math.ceil(numQuestions / 3) * MAX_GENERATION_ATTEMPTS_MULTIPLIER;

  while (questions.length < numQuestions && attempts < maxAttempts) {
    attempts++;
    const loopParams = getRandomForLoopParams();
    // Retry if parameter generation failed (e.g., couldn't create a valid range or names)
    if (!loopParams) {
        log(`Parameter generation failed on attempt ${attempts}, retrying...`);
        continue;
    }

    log(`Attempt ${attempts}: Using params loopVar=${loopParams.loopVarName}, acc=${loopParams.accumulatorName}, init=${loopParams.initialAccumulatorValue}, n=${loopParams.n}, m=${loopParams.m}, step=${loopParams.step}, dir=${loopParams.direction}, elseAction=${loopParams.elseAction}, elseValue=${loopParams.elseValue}`);

    // Attempt to generate one of each difficulty using the same parameters
    const easyEntry = QuestionGenerator.genForLoopSumEasy(loopParams);
    if (easyEntry && questions.length < numQuestions) {
        questions.push(easyEntry);
    }

    const mediumEntry = QuestionGenerator.genForLoopSumMedium(loopParams);
    if (mediumEntry && questions.length < numQuestions) {
        questions.push(mediumEntry);
    }

    const hardEntry = QuestionGenerator.genForLoopSumHard(loopParams);
    if (hardEntry && questions.length < numQuestions) {
        questions.push(hardEntry);
    }

  } // End while loop

  if (attempts >= maxAttempts && questions.length < numQuestions) {
      log(`Warning: Reached max attempts (${maxAttempts}) while trying to generate ${numQuestions} for loop questions. Generated ${questions.length}.`);
  }

  log(`Generated ${questions.length} for loop questions.`);
  // Shuffle the final list to mix difficulties just before returning
  questions.sort(() => Math.random() - 0.5);

  // Return exactly numQuestions
  return questions.slice(0, numQuestions);
}

// Export the main generation function
export { genForQns };
